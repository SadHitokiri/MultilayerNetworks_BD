<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <title>D3.js</title>
  </head>
  <body>
    <style>
      body {
        width: 100%;
        height: 80vh;
        background: linear-gradient(-45deg, #166386, #19376d, #192f6d);
        background-size: 400% 400%;
        animation: gradient 8s ease infinite;
        overflow: hidden;
      }

      svg {
        background-color: whitesmoke;
        margin: auto;
      }

      #svgContainer {
        display: flex;
        width: 100%;
        height: 100%;
        justify-content: center;
        position: relative;
      }
    </style>

    <div id="svgContainer">
      <svg width="1000" height="800"></svg>
      <div id="tooltip" style="position: absolute; visibility: hidden"></div>
    </div>

    <script>
      // Ģenere random dati
      const data = [];
      const layerCount = 3;

      for (let layerIndex = 1; layerIndex <= layerCount; layerIndex++) {
        const layer = {
          layer: layerIndex,
          nodes: [],
          links: [],
        };

        const nodeCount = Math.floor(1000 / layerCount); // virsotnes sk. un sadala slāņos
        const startNodeId = (layerIndex - 1) * nodeCount + 1;

        // cikls, kas izveido virsotnes un pievieno id.
        for (let nodeIndex = 1; nodeIndex <= nodeCount; nodeIndex++) {
          const nodeId = startNodeId + nodeIndex - 1;

          const node = {
            id: nodeId,
            x: Math.floor(Math.random() * 400) + 50, // random virsotne koordinati x asi (no 50 līdz 450)
            y: Math.floor(Math.random() * 300) + 50, // random virsotne koordinati y asi (no 50 līdz 350)
          };

          layer.nodes.push(node);

          if (layerIndex > 1) {
            // pievieno savienojumi starp virsotnes
            const randomNodeIndex = Math.floor(
              Math.random() * data[layerIndex - 2].nodes.length
            );
            const randomNode = data[layerIndex - 2].nodes[randomNodeIndex];

            layer.links.push({
              source: nodeId,
              target: randomNode.id,
            });
          }
        }

        data.push(layer);
      }

      // Izveidojam force simulation, lai norādīt savienojumu garumu
      const simulation = d3
        .forceSimulation()
        .force(
          "link",
          d3
            .forceLink()
            .id((d) => d.id)
            .distance(30) // savienojuma garums
        )
        .force("charge", d3.forceManyBody().strength(-5)) //šķautnes garums
        .force("center", d3.forceCenter(450, 425)); //Vairākslāņu grafu pozicija

      // Vairākslāņu grafu demonstrēšana svg konteinerā
      const svg = d3.select("svg");
      const layerSelection = svg // izveidojam slāņi
        .selectAll(".layer")
        .data(data)
        .enter()
        .append("g")
        .attr("class", "layer");

      const linksSelection = layerSelection // izveidojam šķautnes
        .selectAll("line")
        .data((d) => d.links)
        .enter()
        .append("line")
        .attr("stroke", "black")
        .attr("stroke-width", 0.5);

      const nodesSelection = layerSelection
        // izveidojam virsotnes
        .selectAll("circle")
        .data((d) => d.nodes)
        .enter()
        .append("circle")
        .attr("r", 6)
        .attr("fill", (d) => {
          // ģenere random virsotnes krāsas 
          const colors = ["blue", "green", "red"];
          return colors[Math.floor(Math.random() * colors.length)];
        });

      nodesSelection
        .on("mouseover", (event, d) => {
          // Informacija par virsotne un slāņi
          const layer = data.find((layer) => layer.nodes.includes(d));
          // tooltip izmantots, lai paradīt tekstu ar dati
          d3.select("#tooltip")
            .style("visibility", "visible")
            .html(`Slānis: ${layer.layer} Virsotne: ${d.id}`);
        })
        .on("mousemove", (event) => {
          // kursora pozicija
          d3.select("#tooltip")
            .style("top", event.pageY - 10 + "px")
            .style("left", event.pageX + 10 + "px");
        })
        .on("mouseout", () => {
          // teksts pazūd
          d3.select("#tooltip").style("visibility", "hidden");
        });

      const drag = d3 //funkcija, lai ar kursoru pārbīdīt virsotnes
        .drag()
        .on("start", (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on("drag", (event, d) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on("end", (event, d) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        });

      nodesSelection.call(drag);

      //informācija par virsotņu un šķautņu pozicijām
      simulation.nodes(data.flatMap((d) => d.nodes));
      simulation.force("link").links(data.flatMap((d) => d.links));
      simulation.on("tick", () => {
        linksSelection
          .attr("x1", (d) => d.source.x)
          .attr("y1", (d) => d.source.y)
          .attr("x2", (d) => d.target.x)
          .attr("y2", (d) => d.target.y);

        nodesSelection.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
      });

      // pārvietošanās grafā
      const zoom = d3.zoom().on("zoom", (event) => {
        layerSelection.attr("transform", event.transform);
      });

      svg.call(zoom);
    </script>
  </body>
</html>
